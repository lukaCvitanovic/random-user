JSX
    - JS in rendering enviroment
    - assign DOM elements or components to JS variables
    - za pristupanje variablama ili propovima
        V - {{}}
        R - {}, unutar moze ici bilo koja validni JS izraz
    - nakon compailiranja JSX izrazu postaju obicne funkcije koje se razlucuju u JS objekte
        - JSX moze raditi sa funkcijama koje primaju i vracaju DOM elemente ili componente
        - kondicionalno i iterativno prikazivanje elemenate se obavlja preko JSX funkcija
            - kondicionalno renderiranje moze koristiti ternarne izraze
            - kada zelimo napraviti da komponenta sama sebe ne rendera (a da je parent komponenta prikazuje), tada napravimo da render funkcija vraca null
                - ovo ne ometa rad lifecycle metoda komponetne
            - prikazivanje liste komponenata moze iskoristi sve nacine manipuliranja arrayom koju JS posjeduje ukljucujuci i metode poput map
            - kada komponenta u sebi ima iterativno renderirane komponente ili elemente potrebno je dodijeliti key atribut na svaki element
                - key ima isto dijelovanje i funkciju kao i u Vue
    - JSX koristi cammelCase za imenovanje propova i atributa
    - u pozadini Babel pretvara JSX izraze u React.createElement() pozive koji
        - React.createElement() pozivi stvaraju React elements koji opisuju elemente koje zelimo vidjeti i na osnovu njih modificira DOM
Renderiranje elemenata
    - React elementi su JS objekti koje je jeftino za kreirati
    - React DOM na osnovu React elemenata modificira DOM
    - sve unutar "root" div-a upravlja React DOM
    - za prikazivanje elementa potrebno je pozvati ReactDOM.render()
    - Updatanje renderiranog elementa
        - React elementi su immutable
            - nije moguce mijenjati atribute ili djecu renderiranog elementa
        - jedini nacin za updatanje UI-a ja pozivanjem ReactDOM.render() funkcije
        - ReactDOM promatra predhodno stanje DOM-a sa tranutnim i primjenjuje promjena samo na elemennte koji su razliciti
            - cak i kada se citavi elementi ponovno renderaju
Fragments
    - koristi se za vracanje vise elemenata kao root element
        - primjer su tablice
    - skracena sintaksa je <></>
        - koristi se kao svaka druga komponenta
        - neprima nikakve atribute
    - sa sintasksom <React.Fragment></React.Fragment> moze se koristiti atribut key
        - pozeljno za koristenje prilikom renderanje kolekcije elemenata
Components
    - konceptualno, komponente su poput JS funkcija kojiprimaju inpute preko propova i vracaju React elemente
    - najjednostavniji nacin za definiranjem komponente je putem funkcije
        - funkcijske kompnente prihvacaju jedan props objekt i vracaju React element preko React element
    - komponenta se moze definirati pomocu ES6 klase
    - kod komponenata koje je korisnik napravio React salje sve atribute i children u props objektu
    - React predpostavlja da su korisnicke kompnente napisane sa velikim slovom, a HTML tagovi sa malim slovom
    - props su read-only
        - sve React komponente se moraju ponasati kao pure funkcije prema svojim propovima
            - pure funkcije ne mijenjaju vlastiti input
            - inpure je obrnuto
    - R - stanje/V - data
        - render metoda klasne komponente se poziva svaki put kada se promjena dogodi
        - ako jednu komponentu renderamo u isiti DOM node tada se koristi samo jedna instance te komponenate
            - ovo omogucava koristenje lokalnog stanja i lifecycle hookova
        - za dodavanje stanja potrebno je kreirati contructor metodu
            - u kojoj pozivamo super(props) te definiramo this.state
        - promjene stanja komponente se obavljaju pozivom this.setState() metode
            - jedino mjesto gdje se assigna this.state je u contructor-u
            - ova metoda scheduala promjenu stanja komponente te je rerendera
            - u slucajevima kada novo stanje ovisi o trenutnom stanju komponente pozeljno je koristiti update funkciju kao argument this.setState() metode
                - ovime se dobiva pristup trenutnoj vrijednosti stanja komponente
                    - u slucaju kada se salje objekt kao argument, to onda nije moguce
            - this.setState() omogucava reaktivnost komponente koju Vue ima ugraÄ‘enu
            - radi boljih performansi React grupira vise setState poziva u jedan
            - promjena stanja koju uzrokuje this.setState() radi update na this.state poput assign iz lodash
    - Eventovi
        - imena koriste cammelCase
        - dodjeljuju se na event kao i state ili prop u JSX-u (click={eventHandeler})
        - prevent default se postize pozivanje preventDefault na event (e.preventDefault())
        - isto vrijedi i za stopPropagation()
        - uobicajeni pattern je da je event handeler metoda klasne komponente
        - callback metode nemaju bound-an this na njima
            - defaultno this je undefiend u callback metodama
            - kako bi se this odnosio na komponentu potrebno je boundat this na metodu
                - eksplicitno pozivom bind metode (this.callBack = this.callBack.bind(this))
                - ukoliko se koristi public class fields syntax tada su metode automatski bindane na this
                    - ovo je omoguceno u create-react-app
                - koristenjem arrow funkcija
                    - caviat ove metode je sto se na ovaj nacin svaki put stvara nova instanca callback metode
                        - moze uzrokovati nepotrebne rerendere kod child komponti
                    - preporuca se izbjegavanje ove metode bindanja this-a
            - prosljedivanje argumenta event handeleru se obavlja na 2 nacina
                - koristenjem arrow funkcije (click={(e) => this.eventHandeler(id, e)})
                - koristenjem bind metode (click={this.eventHandeler.bind(this, id)})
                    - event objekt je automatski prosljeden kada se koristi bind metoda
    - lifecycle metode
        -postavljaju se kao metode klasne komponente (isto kao i u Vue)
HOC
    - pattern pisanja komponenti
    - HOC je funkcija koja prima komponentu i pretvara je u novu komponentu
        - za razliku od obicne komponente koja propove pretvara u UI
    - se koristi kao zamjena za mixin-e
    - primarna svrha HOC-a je reusanje patterna logike unutar komponenti
    - HOC je pure funkcija
    - HOC netreba znati sta wrappedComponent radi sa podatcima, wrappedComponent netreba znati odakle dolaze podatci
    - kompinikacija izmedu HOC i wrappedComponent je propbased stoga
        - moguce je jednostavno zamijeniti HOC-ove ukoliko se koriste isit porpovi
    - HOC nesmije mutirati wrappedComponent
        - kako bi HOC moga funkcionirati sa funkcionalnim komponentama koje nemaju lifecycle hookove
        - umjesto mutacije, HOC treba koristiti compoziciju
            - wrapati wrappedComponent u novu komponentu na koju se mogu davati lifecycle hookovi
            - na ovaj nacin se na dobivenu komponentu mogu staviti drugi HOC-ovi te funkcionira sa funkcionalnim komponentama
    - HOC-ovi koriste container komponente kao dio svog patterna
        - container komponente su higher-level komponent koje obavljaju subcripcije
    - HOC-ovi propustaju sve propove za koje HOC netreba znati
    - HOC-ovi se nesmiju koristiti unutar render metoda
    - HOC-ovi ne propustaju ref-ove
        - rijesenje je ref forwarding

Forme
    - drugcije se ponasaju u Reactu nego u obicnom HTML-u jer forma sama sadrzi interno stanje
    - kako bi se dobio pristup podatcima kojima forma barata potrebno je koristiti "kontrolirane komponente"
        - kontolirana komponenta je npr. input form element cije stanje kontrolira React
            - ovime se postize da je React stanje "single source of throught"
            - kontroliranje komponenata raditi kao i u Vue
                - postaviti value prop da se vuce iz React stanje
                - promjena stanje elementa od strane korisnika handela callback koji je React metoda
            - za onemogucavanje unosa se postize postavljanjem vrijednostu u null
            - ponekad nije najbolja opcija za kontroliranjem formu u Reactu
                - zahtjeva dosta boilerplate koda
                - nekad moze biti ne kompaktibilna sa ne React librery-ima
    - alternativa su "uncontroled componenents"
    - Formik
        - zaorkuzeno rijesenje za handelanje formu sa validacijom, biljezenjem posjecenih polja, itd.
        - baziran na kontoliranim komponenatama
Composition vs Inheritance
    - implementacija V slotova u Reactu
        - defaultni slot se koristi na nacin da se na prop children salju elementi koji se tribaju prikazati poput slota
            - ovo se odnosi na genereicku komponentu koja bi trebala imati u sebi <slot />
        - dodavanje slotanih elemenata u komponentu se obavlja na isti nacion kao i u Vue
    - imeplementacija named slotova se obavlja koristenjem proizvodnih imena propova koji primaju JSX elemente
        - iz vanka ti named slotovi se koriste kao propovi kojima su dodjeljeni JSX elementi
    - prop slotovi su implementirani sa render propovima
Accessibility
    - koristenjem aria atributa
        - za razliku od obicnih atributa aira atributi se pisu u cebab caseu
            - koriste se za widgete
    - koristenjem odgovoarajucih HTML elemenata
    - pravilan labeling koristenjem label HTML elementa
        - ovime postavljamo label na form kontrole
            - inputi, selectori, textarea
    - pravilno exposanje errora
    - kontrola fokusa
        - omogucavanje da se stranica moze koristiti samo sa tipkovnicom
        - focus outline samo micati u slucajevima kada ce se ona nadomjestiti sa kusomiziranom variantom istoga
    - skip linkovi koji se koriste za ubrazanje korisnika
        - implementiraju se putem anchora i landmark elemenata poput main i aside
Code-splitting
    - metoda smanjivanja bundela aplikacije
        - dovodi do brzeg loadanja appa
    - najjednostavnija metoda je koristenje dinamicke import() sintakse
    - code splitting na SSR aplikacijama se postize koristenjema Loadable components
    - React.lazy omogucuje pristup dinamicki loadanim komponentama kao normalno loadane komponente
        - radi samo na default export
            - ako se zeli koristiti named export potrebno je napraviti intermedian dokument koji named export exporta kao defaultni
        - nije dostupana za SSR
        - ove komponente se moraju mountati unutar Suspense komponente
            - posjeduje fallback content koji se prikazuje dok se zeljena komponenta loada
        - za handlanje errora prilikom loadanja lazy loadanog sadrzaja koristi se MyErrorBoundary
    - code splitting bazirano na ruti
        - pozeljno jer se na taj nacin codebase dijeli na logicke cijeline
            - korisnici su nauceni na malo loadanje stranice prilikom promjene stranice
Context
    - omgucava prosljedivanje podataka kroz component tree bez prop drilanja
    - obicno se koristi za dijeljenje podataka koji se smatraju globalnima
        - autenticirani korisnik
    - koristenje povecava cupeling izmedu komponenata
        - stoga se preporuca sto rijede koristenje
        - ponekad se koristenje contexta moze zaobici slanjem citave komponente
            - u svrhu izbjegavanja prop drillanja
    - promjena konteksta iz duboke komponente slanje funkcije preko konteksta koja omogucava mijenjanje vrijednosti konteksta
Hooks
    - omogucavaju da fukncionalne komponente imaju iste mogucosti kao i klasne komponenete
    - hook-ovi se nemogu pozivati unutar petlji, if-ova i ugnjezdenih funkcija
    - hook-ovi se mogu pozivati unutra funkcionalnih komponenti i custom hook-ova
        - useState hook omogucava koristenje state-a unutar funkcionalne komponente
            - omogucava postavljanje inicijalne vrijednosti state-a
                - inicijalno stanje nemora biti objekt
                - inicijalno stanje se moze dobite preko kompleksne fukcije
                    - argument useState moze biti funkcija
            - hook vraca trenutno staje i metdu za mijenjanjem stog stanja
                - metoda za mijenjanje stanja prima argument koji postaje novo stanje
                    - za pristup predhodom stanju ka argument se salje fukcije
                        - kao prvi argument je trenutno stanje
            - moguce je visestruko pozivanje useState hook-a
        - useEffect hook omogucava koristenje lifecycle hookove unutar fukcionalnih komponenti
            - pozivom hook-a effect-i se primjenjuju nakon promjene DOM-a
            - pristup componentDidMount u componentDidUpdate je omogucen preko callback fukcije koja se salje kao argument useEffect hook-u
            - pristup componentDidUnmount je omogucent preko return callback funkcije
            - useEffect je pogodan za sve vrste effekata osim onih koji se ticu DOM-a
                - posto se useEffect pokrece nakon paintanja elemenata
                    - za effekte koji se ticu DOM-a koristi se useLayoutEffect hook
            - omoguceno visestruko pozivanje hook-a
            - useEffect se poziva nakon svakog rerendera
                - kako bi se u nekim situacijama ovo izbjeglo radi optimizacije, drugi argument useEffect-a je array vrijdnosti o kojima hook ovisi
                    - promjenom navedenih vrijednosti ce izazvati pozivanje useEffect-a
                        - slanjem praznog array-a uzrokovat ce pozivanje useEffect-a samo jednom
                            - jedan put na mount i unmount
        - useLayoutEffect hook omogucava primjenu efekata na DOM elemente
            - ima istu fukcionalnost kao u useEffect
        - useContext omogucava pristup context objektu
            - prihvaca context objeckt React.createContext i vraca trenutno stanje najblizeg context objekta on parent Provider componente
            - promjenom najblizeg nadredenog context providera hook ce uzrokovati rerender sa novom vrijednocu contexta
        - useReducer omogucava koristenje reducera (Redux)
            - prima 3 argumenta
                - reducer tipa (state, action) => newState
                - pocetno stanje state-a
                - init funkcija koja se koristi za racunanje pocetne vrijednosti state-a
                    - koristno prilikom resetiraja vriednosti state-a
            - pozeljniji od useState-a u situacijama kada state ima vise subvrijednosti
            - ukoliko useReducer vrati isti state kao i trenutni, tada ce se dogiditi bailout ovog hooka
                - nece se nepotrebno rerenderati child componente
        - useCallback
            - prima inline callback i array deppendecie vrijednosti
            - hook vraca memoiziranu verziju callback-a koji se mijenja samo kada se promjeni neki od deppendecie-a u array-u
            - hook je koristan kada se optimiziraim child komponentama salje callback kao referenca za sprijecavanje rerendera (shouldComponentUpdate)
            - useCallback(fn, deps) je jednak useMemo(() => fn, deps)
        - useMemo vraca memoiziranu vrijednost
            - memoizirana vrijednost se ponovno izracunava kada se promijei neki od deps vrijednosti
            - funkcija koja se salje u useMemo se poziva tijekom render
                - u funkciji se nesmiju nalaziti nikakvi effekti, oni spadaju u useEffect
            - ako se ne prosljiedi nikakav deps array vriednost ce se izracunavati na svakom rerender-u
        - useRef vraca mutable objekt ciji .current property je inicijaliziran na dan initialValue argument
            - const refContainer = useRef(initialValue);
            - useRef je kao kutija koja u current property-u moze sadrzavati mutable varijablu
            - useRef je koristan za drzanje bilo koje mutable vrijednosti u current property-u
                - ovo funkcionira jer useRef kreira obicni JS objekt
                    - jedina razlika izmedu useRef i { current: ...} je sta useRef daje isti objekt na svakom renderu
            - useRef ne rerender-a kada se .current promjeni
                - za tu svrhu bolje je koristiti callback ref
        - custom hook-ovi
            - koriste se za ponovno iskoristavanje komponentne logike
                - rade isto sto i highger-order components i reder props samo bez dodavanja nepotrebnih komponenti
            

React Router
    - rutiranje se radi preko JSX-a
        - nije u zasebnom js dokumentu
    - 

Redux
- posjeduje zaseban js file sa svim modulima
    - redux modul se naziva slice
        - slice sadrzi stanje i akcije
            - akcije odgovaraju mutacijama
            - akcije se zasebno exportaju
        - svaki slice exporta svoje reducer funkciju
            - reducer prima stanje slice i akciju s kojom se "modificira" stanje

Potrebni primjeri
- tooltip ili dropdown koji nadilazi overflow hidden parrent
- ispobaj aside element
- probaj customizirat detail element
- renderanje dinaicne liste istih elemenata

Pitanja
- dali je po dizajnu da se preko propova salju callback funkcije koje bi emitale eventove nazad u komponentu koja salje tu metodu
- koja je uloga HTML aria atributa
- React fragments

Podrucja napredovanja
- Accessibility
- Focus control
